syntax = "proto3";

package google.datastore.v1;

import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";


import "google/protobuf/descriptor.proto";


extend google.protobuf.FieldOptions {
  repeated FieldBehavior field_behavior = 1052 [packed = false];
}

enum FieldBehavior {
  FIELD_BEHAVIOR_UNSPECIFIED = 0;
  OPTIONAL = 1;
  REQUIRED = 2;
  OUTPUT_ONLY = 3;
  INPUT_ONLY = 4;
  IMMUTABLE = 5;
  UNORDERED_LIST = 6;
  NON_EMPTY_DEFAULT = 7;
  IDENTIFIER = 8;
}

service Datastore {
  // Just starting with a simple Ping method for testing connection
  rpc Ping(PingRequest) returns (PingResponse);
  
  // The basic Datastore methods we'll implement later
  rpc BeginTransaction(BeginTransactionRequest) returns (BeginTransactionResponse);
  rpc Lookup(LookupRequest) returns (LookupResponse);
  rpc RunQuery(RunQueryRequest) returns (RunQueryResponse);
  rpc Commit(CommitRequest) returns (CommitResponse);
  rpc Rollback(RollbackRequest) returns (RollbackResponse);
}

// Custom message for testing connection
message PingRequest {
  string message = 1;
}

message PingResponse {
  string message = 1;
  google.protobuf.Timestamp server_time = 2;
}

// Basic messages needed for BeginTransaction
message BeginTransactionRequest {
  string project_id = 1;
  string database_id = 2;
  TransactionOptions transaction_options = 3;
}

message BeginTransactionResponse {
  bytes transaction = 1;
}

message TransactionOptions {
  oneof mode {
    ReadWrite read_write = 1;
    ReadOnly read_only = 2;
  }
  
  message ReadWrite {
    bytes previous_transaction = 1;
  }
  
  message ReadOnly {
    google.protobuf.Timestamp read_time = 1;
  }
}

// Placeholder for other message types we'll implement later
message LookupRequest {
  string project_id = 1;
  string database_id = 2;
  repeated Key keys = 3;
}

message LookupResponse {
  repeated EntityResult found = 1;
  repeated EntityResult missing = 2;
  repeated Key deferred = 3;
}

// Simplified versions of core data types
message Key {
  PartitionId partition_id = 1;
  repeated PathElement path = 2;
  
  message PathElement {
    string kind = 1;
    oneof id_type {
      int64 id = 2;
      string name = 3;
    }
  }
}

message PartitionId {
  string project_id = 1;
  string database_id = 2;
  string namespace_id = 3;
}

message EntityResult {
  Entity entity = 1;
  enum ResultType {
    RESULT_TYPE_UNSPECIFIED = 0;
    FULL = 1;
    PROJECTION = 2;
    KEY_ONLY = 3;
  }
  ResultType result_type = 2;
}

message Entity {
  Key key = 1;
  map<string, Value> properties = 3;
}

enum NullValue {
  NULL_VALUE = 0;
}

message LatLng {
  double latitude = 1;
  double longitude = 2;
}

message Value {
  oneof value_type {
    NullValue null_value = 11;  // Now just use the simple name
    bool boolean_value = 1;
    int64 integer_value = 2;
    double double_value = 3;
    google.protobuf.Timestamp timestamp_value = 10;
    Key key_value = 5;
    string string_value = 17;
    bytes blob_value = 18;
    LatLng geo_point_value = 8;
    Entity entity_value = 6;
    ArrayValue array_value = 9;
  }
  int32 meaning = 14;
  bool exclude_from_indexes = 19;
}


message ArrayValue {
  repeated Value values = 1;
}

message ReadOptions {
  enum ReadConsistency {
    // Unspecified. This value must not be used.
    READ_CONSISTENCY_UNSPECIFIED = 0;

    // Strong consistency.
    STRONG = 1;

    // Eventual consistency.
    EVENTUAL = 2;
  }

  oneof consistency_type {
    ReadConsistency read_consistency = 1;
    bytes transaction = 2;
    TransactionOptions new_transaction = 3;
    google.protobuf.Timestamp read_time = 4;
  }
}

message PropertyMask {
  repeated string paths = 1;
}

message ExplainOptions {
  bool analyze = 1;
}

message RunQueryRequest {
  string project_id = 8 [(field_behavior) = REQUIRED];
  string database_id = 9;
  PartitionId partition_id = 2;
  ReadOptions read_options = 1;

  oneof query_type {
    Query query = 3;
    GqlQuery gql_query = 7;
  }
  PropertyMask property_mask = 10;
  ExplainOptions explain_options = 12 [(field_behavior) = OPTIONAL];
}

message Query {
  repeated KindExpression kind = 1;
  Filter filter = 2;
}

message KindExpression {
  string name = 1;
}

message Filter {
  oneof filter_type {
    CompositeFilter composite_filter = 1;
    PropertyFilter property_filter = 2;
  }
}

message CompositeFilter {
  enum Operator {
    OPERATOR_UNSPECIFIED = 0;
    AND = 1;
    OR = 2;
  }
  Operator op = 1;
  repeated Filter filters = 2;
}

message PropertyFilter {
  enum Operator {
    OPERATOR_UNSPECIFIED = 0;
    LESS_THAN = 1;
    LESS_THAN_OR_EQUAL = 2;
    GREATER_THAN = 3;
    GREATER_THAN_OR_EQUAL = 4;
    EQUAL = 5;
    HAS_ANCESTOR = 6;
  }
  PropertyReference property = 1;
  Operator op = 2;
  Value value = 3;
}

message PropertyReference {
  string name = 1;
}

message GqlQuery {
  string query_string = 1;
  bool allow_literals = 2;
  map<string, GqlQueryParameter> named_bindings = 3;
  repeated GqlQueryParameter positional_bindings = 4;
}

message GqlQueryParameter {
  oneof parameter_type {
    Value value = 1;
    bytes cursor = 2;
  }
}

message RunQueryResponse {
  QueryResultBatch batch = 1;
}

message QueryResultBatch {
  repeated EntityResult entity_results = 1;
  enum MoreResultsType {
    MORE_RESULTS_TYPE_UNSPECIFIED = 0;
    NOT_FINISHED = 1;
    MORE_RESULTS_AFTER_LIMIT = 2;
    NO_MORE_RESULTS = 3;
  }
  MoreResultsType more_results = 2;
  bytes end_cursor = 3;
}

// Basic Commit
message CommitRequest {
  enum Mode {
    MODE_UNSPECIFIED = 0;
    TRANSACTIONAL = 1;
    NON_TRANSACTIONAL = 2;
  }
  string project_id = 8 [(field_behavior) = REQUIRED];
  string database_id = 9;
  Mode mode = 5;
  oneof transaction_selector {
    bytes transaction = 1;
    TransactionOptions single_use_transaction = 10;
  }
  repeated Mutation mutations = 6;
}

message Mutation {
  // The possible ways to resolve a conflict detected in a mutation.
  enum ConflictResolutionStrategy {
    // Unspecified. Defaults to `SERVER_VALUE`.
    STRATEGY_UNSPECIFIED = 0;

    // The server entity is kept.
    SERVER_VALUE = 1;

    // The whole commit request fails.
    FAIL = 3;
  }

  // The mutation operation.
  //
  // For `insert`, `update`, and `upsert`:
  // - The entity's key must not be reserved/read-only.
  // - No property in the entity may have a reserved name,
  //   not even a property in an entity in a value.
  // - No value in the entity may have meaning 18,
  //   not even a value in an entity in another value.
  oneof operation {
    // The entity to insert. The entity must not already exist.
    // The entity key's final path element may be incomplete.
    Entity insert = 4;

    // The entity to update. The entity must already exist.
    // Must have a complete key path.
    Entity update = 5;

    // The entity to upsert. The entity may or may not already exist.
    // The entity key's final path element may be incomplete.
    Entity upsert = 6;

    // The key of the entity to delete. The entity may or may not already exist.
    // Must have a complete key path and must not be reserved/read-only.
    Key delete = 7;
  }

  // When set, the server will detect whether or not this mutation conflicts
  // with the current version of the entity on the server. Conflicting mutations
  // are not applied, and are marked as such in MutationResult.
  oneof conflict_detection_strategy {
    // The version of the entity that this mutation is being applied
    // to. If this does not match the current version on the server, the
    // mutation conflicts.
    int64 base_version = 8;

    // The update time of the entity that this mutation is being applied
    // to. If this does not match the current update time on the server, the
    // mutation conflicts.
    google.protobuf.Timestamp update_time = 11;
  }

  // The strategy to use when a conflict is detected. Defaults to
  // `SERVER_VALUE`.
  // If this is set, then `conflict_detection_strategy` must also be set.
  ConflictResolutionStrategy conflict_resolution_strategy = 10;

  // The properties to write in this mutation.
  // None of the properties in the mask may have a reserved name, except for
  // `__key__`.
  // This field is ignored for `delete`.
  //
  // If the entity already exists, only properties referenced in the mask are
  // updated, others are left untouched.
  // Properties referenced in the mask but not in the entity are deleted.
  PropertyMask property_mask = 9;

  // Optional. The transforms to perform on the entity.
  //
  // This field can be set only when the operation is `insert`, `update`,
  // or `upsert`. If present, the transforms are be applied to the entity
  // regardless of the property mask, in order, after the operation.
  repeated PropertyTransform property_transforms = 12
      [(field_behavior) = OPTIONAL];

}

message PropertyTransform {
  // A value that is calculated by the server.
  enum ServerValue {
    // Unspecified. This value must not be used.
    SERVER_VALUE_UNSPECIFIED = 0;

    // The time at which the server processed the request, with millisecond
    // precision. If used on multiple properties (same or different entities)
    // in a transaction, all the properties will get the same server timestamp.
    REQUEST_TIME = 1;
  }

  // Optional. The name of the property.
  //
  // Property paths (a list of property names separated by dots (`.`)) may be
  // used to refer to properties inside entity values. For example `foo.bar`
  // means the property `bar` inside the entity property `foo`.
  //
  // If a property name contains a dot `.` or a backlslash `\`, then that name
  // must be escaped.
  string property = 1 [(field_behavior) = OPTIONAL];

  // The transformation to apply to the property.
  oneof transform_type {
    // Sets the property to the given server value.
    ServerValue set_to_server_value = 2;

    // Adds the given value to the property's current value.
    //
    // This must be an integer or a double value.
    // If the property is not an integer or double, or if the property does not
    // yet exist, the transformation will set the property to the given value.
    // If either of the given value or the current property value are doubles,
    // both values will be interpreted as doubles. Double arithmetic and
    // representation of double values follows IEEE 754 semantics.
    // If there is positive/negative integer overflow, the property is resolved
    // to the largest magnitude positive/negative integer.
    Value increment = 3;

    // Sets the property to the maximum of its current value and the given
    // value.
    //
    // This must be an integer or a double value.
    // If the property is not an integer or double, or if the property does not
    // yet exist, the transformation will set the property to the given value.
    // If a maximum operation is applied where the property and the input value
    // are of mixed types (that is - one is an integer and one is a double)
    // the property takes on the type of the larger operand. If the operands are
    // equivalent (e.g. 3 and 3.0), the property does not change.
    // 0, 0.0, and -0.0 are all zero. The maximum of a zero stored value and
    // zero input value is always the stored value.
    // The maximum of any numeric value x and NaN is NaN.
    Value maximum = 4;

    // Sets the property to the minimum of its current value and the given
    // value.
    //
    // This must be an integer or a double value.
    // If the property is not an integer or double, or if the property does not
    // yet exist, the transformation will set the property to the input value.
    // If a minimum operation is applied where the property and the input value
    // are of mixed types (that is - one is an integer and one is a double)
    // the property takes on the type of the smaller operand. If the operands
    // are equivalent (e.g. 3 and 3.0), the property does not change. 0, 0.0,
    // and -0.0 are all zero. The minimum of a zero stored value and zero input
    // value is always the stored value. The minimum of any numeric value x and
    // NaN is NaN.
    Value minimum = 5;

    // Appends the given elements in order if they are not already present in
    // the current property value.
    // If the property is not an array, or if the property does not yet exist,
    // it is first set to the empty array.
    //
    // Equivalent numbers of different types (e.g. 3L and 3.0) are
    // considered equal when checking if a value is missing.
    // NaN is equal to NaN, and the null value is equal to the null value.
    // If the input contains multiple equivalent values, only the first will
    // be considered.
    //
    // The corresponding transform result will be the null value.
    ArrayValue append_missing_elements = 6;

    // Removes all of the given elements from the array in the property.
    // If the property is not an array, or if the property does not yet exist,
    // it is set to the empty array.
    //
    // Equivalent numbers of different types (e.g. 3L and 3.0) are
    // considered equal when deciding whether an element should be removed.
    // NaN is equal to NaN, and the null value is equal to the null value.
    // This will remove all equivalent values if there are duplicates.
    //
    // The corresponding transform result will be the null value.
    ArrayValue remove_all_from_array = 7;
  }
}
message CommitResponse {
  repeated MutationResult mutation_results = 1;
  int32 index_updates = 2;
}

message MutationResult {
  Key key = 1;
}

message RollbackRequest {
  string project_id = 1;
  string database_id = 2;
  bytes transaction = 3;
}

message RollbackResponse {
}

